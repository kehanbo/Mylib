<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正则表达式</title>
    <script src="../lib/jquery/jquery.js"></script>
    <script src="../lib/Bootstrap/js/bootstrap.js"></script>
    <link rel="stylesheet" href="../lib/Bootstrap/css/bootstrap.css">
</head>

<body>
    <header>
        <h1>正则表达式</h1>
    </header>
    <main>
        <div class="container">
        <p>
            * 正则表达式是一个描述字符模式的对象<br>
            * 可以使用一个RegExp()构造函数来创建RegExp对象<br>
            * 正则表达式直接量也被定义为包含在一对斜杠(/)之间的字符 如： <br>
            * var expression = / pattern / flags;<br>
            * 其中模式（pattern）部分可以使任何简单或者复杂的正则表达式如字符类，限制符，分组等，每个正则表达式可以带有一个或者多个标志（flags）,用以表明正则表达式的行为<br>
            * 本课程值讨论简单模式<br>
            * 正则表达式的匹配模式支持的三个标志<br>
            *	g：表示全局模式（global），即模式将被应用于所有字符串而非发现一个而停止<br>
            *	i：表示不区分大小写（ease-insensitive）模式，在确定匹配想时忽略模式与字符串的大小写<br>
            *	m：表示多行（multiline）模式，即在确定匹配项时忽略模式与字符串的大小写<br>
            * 元字符：( [ { \ ^ $ | ) ? * + . ] }使用时必须转移<br>
            * 特殊字符<br>
            *	\t	/\t/	制表符<br>
            *	\n	/\n/	换行符<br>
            *	\r	/\r/	回车符<br>
            *	\f	/\f/	换页符<br>
            *	\b	/\b/	与回退字符<br>
            *	\v	/\v/	垂直制表符<br>
            *	\0	/\0/	空字符<br>
            *********/<br>
       
           // 预定义类<br>
           //	.	[^\n\r]	除了换行和回车之外的任意字符<br>
           // \d	[0-9]	数字字符<br>
           // \D	[^0-9]	非数字字符<br>
           // \s	[ \t\n\x0B\f\r]	空白字符<br>
           // \S	[^ \t\n\x0B\f\r]	非空白字符<br>
           // \w	[a-zA-Z_0-9]	单词字符(所有的字母)<br>
           // \W	[^a-zA-Z_0-9]	非单词字符<br>
           console.log(111);<br>
           console.log(/\d/.test("3"))//true<br>
           console.log(/\d/.test("a"))//false<br>
           console.log(/\D/.test("b"))//true<br>
           console.log(/\w/.test("c"))//true<br>
           console.log(/\W/.test("正"))//true<br>
           console.log(/\s/.test(" "))//true<br>
           console.log(/\S/.test(" "))//false<br>
           console.log(/\S/.test("则"))//true<br>
           console.log(/./.test("aa"))//true<br>
           console.log(/./.test("  "))//true<br>
        </p>

        <p>
            
    // 简单类<br>
    // 原则上正则的一个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。如<br>
    console.log(222);<br>
    console.log(/ruby/.test("ruby"));//true<br>
    console.log(/[abc]/.test("a"));//true<br>

    // 负向类<br>
    // 也是在那个括号里做文章，前面加个元字符进行取反，表示匹配不能为括号里面的字符。<br>
    console.log(333);<br>
    console.log(/[^abc]/.test("a"));//false<br>
    console.log(/[^abc]/.test("gg"));//true<br>

    // 范围类
    // 有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以在中间加了个横线。<br>
    console.log(444);<br>
    console.log(/[a-f]/.test("c"));//true<br>
    console.log(/[a-f]/.test("l"));//false<br>
    console.log(/[a-z]/.test("m"));//true<br>
    console.log(/[^7-9]/.test("6"));//true<br>
    // 组合类<br>
    // 用中括号匹配不同类型的单个字符。<br>
    console.log(555);<br>
    console.log(/[a-m1-5\n]/.test("b"))//true<br>
    console.log(/[a-m1-5\n]/.test("2"))//true<br>

    // ^	开头	注意不能紧跟于左中括号的后面<br>
    // $	结尾<br>
    // ?		出现零次或一次<br>
    // *		出现零次或多次(任意次)<br>
    // +		出现一次或多次（至少一次）<br>
    // {n}		对应零次或者n次<br>
    // {n,m}	至少出现n次但不超过m次<br>
    // {n,}	至少出现n次(+的升级版)<br>
    console.log(666);<br>
    console.log(/[\u4e00-\u9fa5]{5}/.test("正则表达式"))//true<br>
    console.log(/[\u4e00-\u9fa5]{4}/.test("正则表达式"))//true<br>
    console.log(/^[\u4e00-\u9fa5]+$/.test("正则表达式"))//true<br>
    console.log(/^[\u4e00-\u9fa5]+$/.test("正则表达式&*@@"))//false<br>
    console.log(/\d{6}/.test("123456"))//true<br>
    console.log(/[ruby]{2}/.test("rr"))//true<br>
    console.log(/[ruby]{2}/.test("ru"))//true<br>
    console.log(/[ruby]{2}/.test("ry"))//true<br>
        </p>

        <p>
            
//正则表达式基础知识<br>

//星号(*) : 星号代表匹配它前面一个字符任意遍(0或任意次)<br>

//加号(+): 加号是一个与星号(*)类似的通配符，它也是数量词，表示匹配前面的字符一次或多次（至少一次).<br>
//它与星号的差别就在这里，星号可以匹配0次，加号则必须一次以上。<br>

//问号(?): 问号也是一个数量词，它代表匹配前一个字符0或1次。<br>


//中括号[]： 中括号用来表示一个字符集合，<br>
//如果这个集合有很多元素，如26个字母，数字等，一个个地写在中括号里，未免太麻烦太蠢笨，<br>
//这时可以用连字符(hyphen)来表示一个范围，<br>
// 如:[a-z]表示小写字母的集合，<br>
// [a-zA-Z]表示大小写字母的集合。<br>
// 脱字符^ (caret).<br>
// 这种写法表示，匹配任何不在该集合中的字符，与上面的用法刚好相反<br>


//特殊字符：<br>
//    \w -- (小写w) 表示字母或数字，等价于 [a-zA-Z0-9]<br>
//    \W -- (大写W)非字母且非数字，与\w相反 等价于 '[^A-Za-z0-9_]'<br>
//    \s  --  (小写s)匹配一个空格字符，包括：空格，换行，回车,tab,等价于[ \n\r\t\f]<br>
//    \S --  (大写S)匹配非空格字符，\s的相反 等价于 [^ \f\n\r\t\v]。<br>
//    \d -- 表示10进制数字，等价于 [0-9]<br>
//    \D --	匹配一个非数字字符。等价于 [^0-9]。<br>

//    \f	匹配一个换页符。等价于 \x0c 和 \cL。<br>
//    \n	匹配一个换行符。等价于 \x0a 和 \cJ。<br>
//    \r	匹配一个回车符。等价于 \x0d 和 \cM。<br>
//    \t	匹配一个制表符。等价于 \x09 和 \cI。<br>
//    \v	匹配一个垂直制表符。等价于 \x0b 和 \cK。<br>



//    大括号:{}<br>
//    大括号的作用是指定重复前面一个字符多少遍:<br>
//    {N} 重复N遍<br>
//    {n,m} 重复 n~m 遍<br>
//    {n,}  至少重复n遍<br>
//    {,m} 至多重复m遍<br>


//定位符：<br>
//    ^	    匹配输入字符串的开始位置。<br>
//    $	    匹配输入字符串的结束位置。<br>
//   \b     匹配一个单词边界，也就是指单词和空格间的位置。//例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。<br>
//    \B	和\b相反，匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。<br>

        </p>
    </main>
</div>
</body>

</html>
<script type="text/javascript">
    /*********
     * 正则表达式是一个描述字符模式的对象
     * 可以使用一个RegExp()构造函数来创建RegExp对象
     * 正则表达式直接量也被定义为包含在一对斜杠(/)之间的字符 如： 
     * var expression = / pattern / flags;
     * 其中模式（pattern）部分可以使任何简单或者复杂的正则表达式如字符类，限制符，分组等，每个正则表达式可以带有一个或者多个标志（flags）,用以表明正则表达式的行为
     * 本课程值讨论简单模式
     * 正则表达式的匹配模式支持的三个标志
     *	g：表示全局模式（global），即模式将被应用于所有字符串而非发现一个而停止
     *	i：表示不区分大小写（ease-insensitive）模式，在确定匹配想时忽略模式与字符串的大小写
     *	m：表示多行（multiline）模式，即在确定匹配项时忽略模式与字符串的大小写
     * 元字符：( [ { \ ^ $ | ) ? * + . ] }使用时必须转移
     * 特殊字符
     *	\t	/\t/	制表符
     *	\n	/\n/	换行符
     *	\r	/\r/	回车符
     *	\f	/\f/	换页符
     *	\b	/\b/	与回退字符
     *	\v	/\v/	垂直制表符
     *	\0	/\0/	空字符
     *********/

    // 预定义类
    //	.	[^\n\r]	除了换行和回车之外的任意字符
    // \d	[0-9]	数字字符
    // \D	[^0-9]	非数字字符
    // \s	[ \t\n\x0B\f\r]	空白字符
    // \S	[^ \t\n\x0B\f\r]	非空白字符
    // \w	[a-zA-Z_0-9]	单词字符(所有的字母)
    // \W	[^a-zA-Z_0-9]	非单词字符
    console.log(111);
    console.log(/\d/.test("3"))//true
    console.log(/\d/.test("a"))//false
    console.log(/\D/.test("b"))//true
    console.log(/\w/.test("c"))//true
    console.log(/\W/.test("正"))//true
    console.log(/\s/.test(" "))//true
    console.log(/\S/.test(" "))//false
    console.log(/\S/.test("则"))//true
    console.log(/./.test("aa"))//true
    console.log(/./.test("  "))//true



    // 简单类
    // 原则上正则的一个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。如
    console.log(222);
    console.log(/ruby/.test("ruby"));//true
    console.log(/[abc]/.test("a"));//true

    // 负向类
    // 也是在那个括号里做文章，前面加个元字符进行取反，表示匹配不能为括号里面的字符。
    console.log(333);
    console.log(/[^abc]/.test("a"));//false
    console.log(/[^abc]/.test("gg"));//true

    // 范围类
    // 有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以在中间加了个横线。
    console.log(444);
    console.log(/[a-f]/.test("c"));//true
    console.log(/[a-f]/.test("l"));//false
    console.log(/[a-z]/.test("m"));//true
    console.log(/[^7-9]/.test("6"));//true
    // 组合类
    // 用中括号匹配不同类型的单个字符。
    console.log(555);
    console.log(/[a-m1-5\n]/.test("b"))//true
    console.log(/[a-m1-5\n]/.test("2"))//true

    // ^	开头	注意不能紧跟于左中括号的后面
    // $	结尾
    // ?		出现零次或一次
    // *		出现零次或多次(任意次)
    // +		出现一次或多次（至少一次）
    // {n}		对应零次或者n次
    // {n,m}	至少出现n次但不超过m次
    // {n,}	至少出现n次(+的升级版)
    console.log(666);
    console.log(/[\u4e00-\u9fa5]{5}/.test("正则表达式"))//true
    console.log(/[\u4e00-\u9fa5]{4}/.test("正则表达式"))//true
    console.log(/^[\u4e00-\u9fa5]+$/.test("正则表达式"))//true
    console.log(/^[\u4e00-\u9fa5]+$/.test("正则表达式&*@@"))//false
    console.log(/\d{6}/.test("123456"))//true
    console.log(/[ruby]{2}/.test("rr"))//true
    console.log(/[ruby]{2}/.test("ru"))//true
    console.log(/[ruby]{2}/.test("ry"))//true




//正则表达式基础知识

    //星号(*) : 星号代表匹配它前面一个字符任意遍(0或任意次)

    //加号(+): 加号是一个与星号(*)类似的通配符，它也是数量词，表示匹配前面的字符一次或多次（至少一次).
    //它与星号的差别就在这里，星号可以匹配0次，加号则必须一次以上。

    //问号(?): 问号也是一个数量词，它代表匹配前一个字符0或1次。


    //中括号[]： 中括号用来表示一个字符集合，
    //如果这个集合有很多元素，如26个字母，数字等，一个个地写在中括号里，未免太麻烦太蠢笨，
    //这时可以用连字符(hyphen)来表示一个范围，
    // 如:[a-z]表示小写字母的集合，
    // [a-zA-Z]表示大小写字母的集合。
    // 脱字符^ (caret).
    // 这种写法表示，匹配任何不在该集合中的字符，与上面的用法刚好相反


    //特殊字符：
    //    \w -- (小写w) 表示字母或数字，等价于 [a-zA-Z0-9]
    //    \W -- (大写W)非字母且非数字，与\w相反 等价于 '[^A-Za-z0-9_]'
    //    \s  --  (小写s)匹配一个空格字符，包括：空格，换行，回车,tab,等价于[ \n\r\t\f]
    //    \S --  (大写S)匹配非空格字符，\s的相反 等价于 [^ \f\n\r\t\v]。
    //    \d -- 表示10进制数字，等价于 [0-9]
    //    \D --	匹配一个非数字字符。等价于 [^0-9]。

    //    \f	匹配一个换页符。等价于 \x0c 和 \cL。
    //    \n	匹配一个换行符。等价于 \x0a 和 \cJ。
    //    \r	匹配一个回车符。等价于 \x0d 和 \cM。
    //    \t	匹配一个制表符。等价于 \x09 和 \cI。
    //    \v	匹配一个垂直制表符。等价于 \x0b 和 \cK。



    //    大括号:{}
    //    大括号的作用是指定重复前面一个字符多少遍:
    //    {N} 重复N遍
    //    {n,m} 重复 n~m 遍
    //    {n,}  至少重复n遍
    //    {,m} 至多重复m遍


    //定位符：
    //    ^	    匹配输入字符串的开始位置。
    //    $	    匹配输入字符串的结束位置。
    //   \b     匹配一个单词边界，也就是指单词和空格间的位置。//例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
    //    \B	和\b相反，匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。

</script>